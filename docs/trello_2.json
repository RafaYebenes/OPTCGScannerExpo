{
  "name": "OPSCANNER - Tareas Detalladas",
  "desc": "Importaci√≥n completa con 28 tareas detalladas",
  "lists": [
    {
      "name": "BUGS",
      "cards": [
        {
          "name": "C√≥digo de carta no desaparece",
          "desc": "**Prioridad:** üî¥ Alta\n**Estimaci√≥n:** 2-4 horas\n\n## Problema\nDespu√©s de escanear una carta, el c√≥digo detectado permanece visible en la UI cuando deber√≠a desaparecer tras el feedback de √©xito.\n\n## An√°lisis T√©cnico\nEl estado `detectionState.lastSavedCode` no se est√° limpiando correctamente despu√©s del timeout de animaci√≥n.\n\n## Soluci√≥n Propuesta\n```typescript\n// En useCardScanner.ts\nsetTimeout(() => {\n  setDetectionState(prev => ({\n    ...prev,\n    lastSavedCode: null,\n    isDetecting: false\n  }));\n}, 2000);\n```\n\n## Archivos Afectados\n- hooks/useCardScanner.ts\n- components/DetectionFeedback.tsx\n\n## ‚úÖ Checklist\n- [ ] Identificar el timeout actual en DetectionFeedback\n- [ ] A√±adir cleanup de lastSavedCode en useCardScanner\n- [ ] Verificar que FadeOutUp funciona correctamente\n- [ ] Testing en dispositivo f√≠sico"
        },
        {
          "name": "Revisar textos de los sets en cardDetail",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 1-2 horas\n\n## Problema\nLos nombres de sets en CardDetailScreen no se muestran correctamente o est√°n incompletos.\n\n## Soluci√≥n\nCrear mapeo completo de sets en utils/constants.ts y actualizar cardCodeParser.\n\n## Archivos Afectados\n- utils/constants.ts\n- utils/cardCodeParser.ts\n- screens/CardDetailScreen.tsx\n\n## ‚úÖ Checklist\n- [ ] Investigar lista completa de sets del juego\n- [ ] Crear constante SET_NAMES con todos los sets\n- [ ] Actualizar getSetName() para usar la constante\n- [ ] Verificar en CardDetailScreen que se muestran correctamente"
        },
        {
          "name": "Im√°genes Alters",
          "desc": "**Prioridad:** üî¥ Alta\n**Estimaci√≥n:** 8-12 horas\n\n## Problema\nLas URLs de im√°genes de cartas alternate art no se generan correctamente.\n\n## Tipos de Variantes\n1. Normal: OP01-001.png\n2. Parallel (V2): OP01-001_p1.png\n3. Manga/Special (V3): OP01-001_p2.png\n4. SP (Special): Investigar patr√≥n\n5. Winner/Judge: Investigar patr√≥n\n\n## Soluci√≥n\nCrear script verify_card_images.js para verificar patrones y actualizar import_cards.js.\n\n## ‚úÖ Checklist\n- [ ] Investigar patrones de URLs para cada variante\n- [ ] Crear script verify_card_images.js\n- [ ] Ejecutar verificaci√≥n sobre BD actual\n- [ ] Documentar todos los patrones encontrados\n- [ ] Actualizar generateImageUrl() con todos los patrones\n- [ ] Re-ejecutar import_cards.js con nueva l√≥gica\n- [ ] Verificar en app que todas las im√°genes cargan"
        }
      ]
    },
    {
      "name": "USERS",
      "cards": [
        {
          "name": "Perfil de usuario",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 6-8 horas\n\n## Objetivo\nCrear pantalla de perfil con informaci√≥n personal, estad√≠sticas y configuraci√≥n.\n\n## Funcionalidades\n- Avatar editable\n- Estad√≠sticas de colecci√≥n\n- Configuraci√≥n de app\n\n## Implementaci√≥n\nCrear ProfileScreen con componentes: ProfileHeader, StatsCard, SettingsSection.\n\n## ‚úÖ Checklist\n- [ ] Crear nueva pantalla ProfileScreen\n- [ ] Implementar ProfileHeader con avatar editable\n- [ ] Crear componente StatsCard\n- [ ] Implementar SettingsSection\n- [ ] A√±adir columnas a tabla profiles\n- [ ] Configurar Supabase Storage para avatares\n- [ ] A√±adir navegaci√≥n desde CollectionScreen"
        },
        {
          "name": "Amigos",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 12-16 horas\n\n## Objetivo\nSistema de amigos para compartir colecciones.\n\n## Funcionalidades\n- B√∫squeda de usuarios\n- Enviar/aceptar solicitudes\n- Ver colecci√≥n de amigos\n\n## Modelo de Datos\nCrear tablas: friend_requests, friendships.\n\n## ‚úÖ Checklist\n- [ ] Crear tablas friend_requests y friendships\n- [ ] Generar friend_code para usuarios\n- [ ] Implementar friendsService\n- [ ] Crear FriendsScreen\n- [ ] Implementar AddFriendScreen\n- [ ] Crear FriendProfileScreen\n- [ ] Testing de flujos"
        },
        {
          "name": "Pr√©stamo de cartas",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 10-14 horas\n\n## Objetivo\nSistema para registrar pr√©stamos de cartas entre amigos.\n\n## Funcionalidades\n- Crear pr√©stamo\n- Marcar como devuelto\n- Ver pr√©stamos activos\n\n## Modelo\nTabla card_loans con validaciones.\n\n## ‚úÖ Checklist\n- [ ] Crear tabla card_loans\n- [ ] Implementar loanService\n- [ ] Crear LoansScreen\n- [ ] Implementar CreateLoanScreen\n- [ ] Actualizar l√≥gica de quantity\n- [ ] Testing de edge cases"
        }
      ]
    },
    {
      "name": "SCANNER",
      "cards": [
        {
          "name": "Cambiar par√°metros de an√°lisis en funci√≥n de la luz disponible",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 6-8 horas\n\n## Objetivo\nAjustar par√°metros de OCR seg√∫n iluminaci√≥n.\n\n## Implementaci√≥n\nCrear hook useLightDetection y ajustar throttle/contraste din√°micamente.\n\n## ‚úÖ Checklist\n- [ ] Crear hook useLightDetection\n- [ ] Implementar preprocessImage con ajuste de contraste\n- [ ] A√±adir configuraci√≥n din√°mica en ScannerScreen\n- [ ] Crear indicador visual en ScanOverlay\n- [ ] Testing en diferentes condiciones"
        },
        {
          "name": "Identificaci√≥n mangas, sp y cartas especiales m√°s all√° de los alters",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 8-10 horas\n\n## Objetivo\nDetectar correctamente cartas Manga, SP, Winner, Judge.\n\n## Estrategia\nSistema h√≠brido: detectar c√≥digo ‚Üí mostrar selector si hay m√∫ltiples variantes.\n\n## Implementaci√≥n\nCrear componente VariantSelector y m√©todo getCardVariants().\n\n## ‚úÖ Checklist\n- [ ] Implementar getCardVariants() en supabaseService\n- [ ] Crear componente VariantSelector\n- [ ] Integrar selector en flujo de escaneo\n- [ ] Dise√±ar UI del selector\n- [ ] Testing con cartas de m√∫ltiples variantes"
        },
        {
          "name": "A√±adir cartas promo, judge y winner",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 4-6 horas\n\n## Objetivo\nImportar cartas especiales con c√≥digos P-XXX, J-XXX, W-XXX.\n\n## Implementaci√≥n\nActualizar cardCodeParser y crear script import_special_cards.js.\n\n## ‚úÖ Checklist\n- [ ] Investigar lista completa de cartas especiales\n- [ ] Actualizar cardCodeParser para c√≥digos P/J/W/S\n- [ ] Crear sets especiales en BD\n- [ ] Crear script import_special_cards.js\n- [ ] Ejecutar importaci√≥n\n- [ ] Testing de escaneo"
        }
      ]
    },
    {
      "name": "DECKS",
      "cards": [
        {
          "name": "Crear deck",
          "desc": "**Prioridad:** üî¥ Alta\n**Estimaci√≥n:** 16-20 horas\n\n## Objetivo\nSistema completo de creaci√≥n de mazos con validaci√≥n de reglas.\n\n## Reglas One Piece TCG\n- 50 cartas exactas (Leader + 49)\n- M√°ximo 4 copias por carta\n- Colores compatibles con Leader\n\n## Implementaci√≥n\nCrear tablas decks/deck_cards, DeckBuilderScreen, validaci√≥n completa.\n\n## ‚úÖ Checklist\n- [ ] Crear tablas decks y deck_cards\n- [ ] Implementar deckService completo\n- [ ] Crear DecksListScreen\n- [ ] Implementar DeckBuilderScreen\n- [ ] Crear CardSelectorScreen\n- [ ] Implementar validaci√≥n de reglas\n- [ ] Testing exhaustivo"
        },
        {
          "name": "Importar deck",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 6-8 horas\n\n## Objetivo\nImportar mazos desde texto (One Piece Top Decks, Limitless TCG).\n\n## Formatos\n- OPTD: \"4x OP01-001 Nombre\"\n- Limitless: \"4 OP01-001 Nombre [Leader]\"\n- JSON propio\n\n## Implementaci√≥n\nParser flexible + ImportDeckScreen.\n\n## ‚úÖ Checklist\n- [ ] Implementar parseDecklistText\n- [ ] Crear m√©todo importDeck\n- [ ] Implementar ImportDeckScreen\n- [ ] Testing con decklists reales\n- [ ] Gestionar cartas no encontradas"
        },
        {
          "name": "Publicar deck",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 8-10 horas\n\n## Objetivo\nCompartir mazos p√∫blicamente con la comunidad.\n\n## Funcionalidades\n- Toggle is_public\n- Explorar decks p√∫blicos\n- Clonar deck ajeno\n\n## Implementaci√≥n\nPublicDecksScreen + sistema de likes/views.\n\n## ‚úÖ Checklist\n- [ ] A√±adir columnas views, clones, likes\n- [ ] Implementar publishDeck, getPublicDecks\n- [ ] Crear PublicDecksScreen\n- [ ] Crear RPC functions en Supabase\n- [ ] Testing de permisos"
        },
        {
          "name": "Exportar deck",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 4-6 horas\n\n## Objetivo\nExportar mazos a texto/JSON/imagen.\n\n## Formatos\n- Texto (decklist)\n- JSON\n- URL compartible\n\n## Implementaci√≥n\nM√©todos exportDeckText(), exportDeckJSON() + Share API.\n\n## ‚úÖ Checklist\n- [ ] Implementar exportDeckText()\n- [ ] Implementar exportDeckJSON()\n- [ ] A√±adir bot√≥n de exportar\n- [ ] Crear ActionSheet con opciones\n- [ ] Testing en iOS y Android"
        }
      ]
    },
    {
      "name": "API_MKM",
      "cards": [
        {
          "name": "Actualizar scrapper",
          "desc": "**Prioridad:** üî¥ Alta\n**Estimaci√≥n:** 8-12 horas\n\n## Problema\nCloudflare ha cambiado detecci√≥n de bots. El scrapper actual no funciona.\n\n## Soluciones Posibles\n1. **Puppeteer con stealth plugin**\n2. **Playwright con bypass de Cloudflare**\n3. **Servicio proxy rotativo** (ScraperAPI, Bright Data)\n4. **API oficial de Cardmarket** (requiere aprobaci√≥n)\n\n## Implementaci√≥n Recomendada\n```javascript\n// scripts/scraper_mkm.js\nconst { chromium } = require('playwright-extra');\nconst stealth = require('puppeteer-extra-plugin-stealth')();\n\nasync function scrapeMKM(cardCode) {\n  const browser = await chromium.launch({\n    headless: true,\n    args: ['--disable-blink-features=AutomationControlled']\n  });\n  \n  const page = await browser.newPage();\n  \n  // Setear headers realistas\n  await page.setExtraHTTPHeaders({\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)...',\n    'Accept-Language': 'en-US,en;q=0.9'\n  });\n  \n  const url = `https://www.cardmarket.com/en/OnePiece/Products/Singles/${cardCode}`;\n  await page.goto(url, { waitUntil: 'networkidle' });\n  \n  // Esperar bypass de Cloudflare\n  await page.waitForSelector('.price-container', { timeout: 15000 });\n  \n  const price = await page.$eval('.price', el => el.textContent);\n  \n  await browser.close();\n  return parseFloat(price);\n}\n```\n\n## Alternativa con Servicio Proxy\n```javascript\nconst axios = require('axios');\n\nasync function scrapeMKMWithProxy(cardCode) {\n  const response = await axios.get('http://api.scraperapi.com', {\n    params: {\n      api_key: 'TU_API_KEY',\n      url: `https://www.cardmarket.com/en/OnePiece/Products/Singles/${cardCode}`,\n      render: true // JavaScript rendering\n    }\n  });\n  \n  // Parsear HTML con cheerio\n  const $ = cheerio.load(response.data);\n  const price = $('.price').text();\n  return parseFloat(price);\n}\n```\n\n## Costo Estimado\n- ScraperAPI: $49/mes (10,000 requests)\n- Bright Data: $500/mes (m√°s robusto)\n- Playwright self-hosted: $0 (puede bloquearse)\n\n## ‚úÖ Checklist\n- [ ] Investigar detecci√≥n actual de Cloudflare\n- [ ] Evaluar Playwright vs Puppeteer vs Proxy service\n- [ ] Implementar soluci√≥n elegida\n- [ ] Testing con 10-20 cartas\n- [ ] A√±adir retry logic y error handling\n- [ ] Implementar rate limiting (evitar ban)\n- [ ] Documentar headers y configuraci√≥n\n- [ ] Evaluar costos vs beneficio"
        },
        {
          "name": "A√±adir llamadas a la api desde el front",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 4-6 horas\n\n## Objetivo\nPermitir actualizar precios de cartas desde la app (bot√≥n \"Actualizar precio\").\n\n## Arquitectura\n```\nFrontend (React Native)\n    ‚Üì HTTP Request\nSupabase Edge Function\n    ‚Üì Llama a\nScrapper Script / API MKM\n    ‚Üì Retorna precio\nActualiza BD ‚Üí Frontend\n```\n\n## Implementaci√≥n\n\n### Edge Function (Supabase)\n```typescript\n// supabase/functions/fetch-card-price/index.ts\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\n\nserve(async (req) => {\n  const { cardCode } = await req.json();\n  \n  // Llamar al scrapper (puede estar en otro servicio)\n  const price = await scrapeMKM(cardCode);\n  \n  // Actualizar BD\n  const supabase = createClient(\n    Deno.env.get('SUPABASE_URL')!,\n    Deno.env.get('SUPABASE_SERVICE_KEY')!\n  );\n  \n  await supabase\n    .from('cards')\n    .update({ \n      market_price_eur: price,\n      updated_at: new Date().toISOString()\n    })\n    .eq('code', cardCode);\n  \n  return new Response(JSON.stringify({ price }), {\n    headers: { 'Content-Type': 'application/json' }\n  });\n});\n```\n\n### Frontend Service\n```typescript\n// services/priceService.ts\nexport const priceService = {\n  async updateCardPrice(cardCode: string) {\n    const { data, error } = await supabase.functions.invoke('fetch-card-price', {\n      body: { cardCode }\n    });\n    \n    if (error) throw error;\n    return data.price;\n  },\n  \n  async getLatestPrice(cardCode: string) {\n    const { data } = await supabase\n      .from('cards')\n      .select('market_price_eur, updated_at')\n      .eq('code', cardCode)\n      .single();\n    \n    // Si el precio tiene m√°s de 24h, actualizarlo\n    const lastUpdate = new Date(data.updated_at);\n    const hoursSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60);\n    \n    if (hoursSinceUpdate > 24) {\n      return await this.updateCardPrice(cardCode);\n    }\n    \n    return data.market_price_eur;\n  }\n};\n```\n\n### UI Component\n```typescript\n// screens/CardDetailScreen.tsx\nconst [updating, setUpdating] = useState(false);\n\nconst handleUpdatePrice = async () => {\n  setUpdating(true);\n  try {\n    const newPrice = await priceService.updateCardPrice(card.code);\n    setCard(prev => ({ ...prev, market_price_eur: newPrice }));\n    Alert.alert('Precio actualizado', `‚Ç¨${newPrice.toFixed(2)}`);\n  } catch (error) {\n    Alert.alert('Error', 'No se pudo actualizar el precio');\n  } finally {\n    setUpdating(false);\n  }\n};\n\n<Button \n  title={updating ? \"Actualizando...\" : \"Actualizar Precio\"}\n  onPress={handleUpdatePrice}\n  disabled={updating}\n/>\n```\n\n## Rate Limiting\n```typescript\n// L√≠mite: 1 actualizaci√≥n por carta cada 6 horas\nconst RATE_LIMIT_HOURS = 6;\n\n// En Edge Function\nconst { data: lastUpdate } = await supabase\n  .from('price_updates')\n  .select('updated_at')\n  .eq('card_code', cardCode)\n  .order('updated_at', { ascending: false })\n  .limit(1)\n  .single();\n\nif (lastUpdate) {\n  const hoursSince = (Date.now() - new Date(lastUpdate.updated_at)) / (1000 * 60 * 60);\n  if (hoursSince < RATE_LIMIT_HOURS) {\n    return new Response(\n      JSON.stringify({ error: 'Rate limit exceeded' }),\n      { status: 429 }\n    );\n  }\n}\n```\n\n## ‚úÖ Checklist\n- [ ] Crear Edge Function en Supabase\n- [ ] Implementar priceService en frontend\n- [ ] A√±adir bot√≥n actualizar en CardDetailScreen\n- [ ] Implementar rate limiting\n- [ ] A√±adir loading states\n- [ ] Testing con varias cartas\n- [ ] Gestionar errores (carta no encontrada, timeout)\n- [ ] Documentar l√≠mites de uso"
        },
        {
          "name": "Crear script que obtenga el precio de todas las cartas y los setee en nuestra bbdd, configurar para que se repita todas las ma√±anas",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 6-8 horas\n\n## Objetivo\nActualizaci√≥n autom√°tica masiva de precios mediante cron job.\n\n## Arquitectura\n```\nCron Job (GitHub Actions / Supabase Cron)\n    ‚Üì Cada d√≠a 6:00 AM\nScript update_all_prices.js\n    ‚Üì Query BD\nObtener todas las cartas\n    ‚Üì Batch de 10 cartas\nScrapper ‚Üí API MKM\n    ‚Üì Actualizar precios\nSupabase BD\n```\n\n## Implementaci√≥n\n\n### Script Principal\n```javascript\n// scripts/update_all_prices.js\nconst { createClient } = require('@supabase/supabase-js');\nconst pLimit = require('p-limit');\n\nconst supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_KEY);\nconst limit = pLimit(5); // M√°ximo 5 requests concurrentes\n\nasync function updateAllPrices() {\n  console.log('üöÄ Iniciando actualizaci√≥n de precios...');\n  \n  // 1. Obtener todas las cartas\n  const { data: cards } = await supabase\n    .from('cards')\n    .select('id, code, variant')\n    .order('updated_at', { ascending: true }) // Las m√°s antiguas primero\n    .limit(500); // Actualizar 500 cartas por d√≠a\n  \n  console.log(`üìä Total cartas a actualizar: ${cards.length}`);\n  \n  let updated = 0;\n  let errors = 0;\n  \n  // 2. Actualizar en batches con rate limiting\n  const promises = cards.map((card, idx) => \n    limit(async () => {\n      try {\n        // Delay entre requests (evitar ban)\n        await new Promise(resolve => setTimeout(resolve, idx * 200));\n        \n        const price = await scrapeMKM(card.code);\n        \n        await supabase\n          .from('cards')\n          .update({ \n            market_price_eur: price,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', card.id);\n        \n        updated++;\n        if (updated % 50 === 0) {\n          console.log(`‚úÖ Actualizadas: ${updated}/${cards.length}`);\n        }\n      } catch (error) {\n        errors++;\n        console.error(`‚ùå Error en ${card.code}: ${error.message}`);\n      }\n    })\n  );\n  \n  await Promise.all(promises);\n  \n  console.log(`\\nüìà Resumen:\n    ‚úÖ Actualizadas: ${updated}\n    ‚ùå Errores: ${errors}\n    ‚è±Ô∏è  Tiempo total: ${(Date.now() - startTime) / 1000}s\n  `);\n  \n  // 3. Guardar log en BD\n  await supabase.from('price_update_logs').insert({\n    total_cards: cards.length,\n    updated: updated,\n    errors: errors,\n    executed_at: new Date().toISOString()\n  });\n}\n\nupdateAllPrices();\n```\n\n### Configuraci√≥n Cron con GitHub Actions\n```yaml\n# .github/workflows/update-prices.yml\nname: Update Card Prices\n\non:\n  schedule:\n    - cron: '0 6 * * *'  # Cada d√≠a a las 6:00 AM UTC\n  workflow_dispatch:  # Permite ejecuci√≥n manual\n\njobs:\n  update-prices:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '20'\n      \n      - name: Install dependencies\n        run: |\n          cd scripts\n          npm install\n      \n      - name: Update prices\n        env:\n          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}\n          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}\n        run: node scripts/update_all_prices.js\n      \n      - name: Notify completion\n        if: always()\n        uses: actions/github-script@v6\n        with:\n          script: |\n            console.log('Price update completed');\n```\n\n### Alternativa: Supabase Edge Function + pg_cron\n```sql\n-- Habilitar pg_cron en Supabase\nCREATE EXTENSION IF NOT EXISTS pg_cron;\n\n-- Crear funci√≥n que llama al Edge Function\nCREATE OR REPLACE FUNCTION trigger_price_update()\nRETURNS void AS $$\nBEGIN\n  PERFORM net.http_post(\n    url := 'https://YOUR_PROJECT.supabase.co/functions/v1/update-all-prices',\n    headers := '{\"Authorization\": \"Bearer YOUR_ANON_KEY\"}'::jsonb\n  );\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Programar ejecuci√≥n diaria a las 6 AM\nSELECT cron.schedule(\n  'update-card-prices',\n  '0 6 * * *',\n  'SELECT trigger_price_update();'\n);\n```\n\n## Optimizaciones\n\n### Actualizaci√≥n Inteligente\n```javascript\n// Solo actualizar cartas con movimiento de precio reciente\nconst { data: cards } = await supabase\n  .from('cards')\n  .select('*')\n  .or('rarity.in.(SR,SEC,SP),market_price_eur.gte.10') // Solo cartas valiosas\n  .order('updated_at', { ascending: true });\n```\n\n### Cach√© de Precios\n```javascript\n// Guardar hist√≥rico de precios\nawait supabase.from('price_history').insert({\n  card_id: card.id,\n  price_eur: newPrice,\n  recorded_at: new Date()\n});\n```\n\n## Monitoreo\n```javascript\n// Crear tabla de logs\nCREATE TABLE price_update_logs (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  total_cards integer,\n  updated integer,\n  errors integer,\n  avg_duration_ms integer,\n  executed_at timestamp DEFAULT now()\n);\n```\n\n## ‚úÖ Checklist\n- [ ] Crear script update_all_prices.js\n- [ ] Implementar rate limiting (5 concurrent max)\n- [ ] Configurar GitHub Actions workflow\n- [ ] A√±adir tabla price_update_logs\n- [ ] Testing en modo dry-run\n- [ ] Ejecutar primera actualizaci√≥n masiva\n- [ ] Configurar alertas por email si hay errores\n- [ ] Documentar costos de scraping\n- [ ] Optimizar: solo actualizar cartas valiosas"
        }
      ]
    },
    {
      "name": "Graficos",
      "cards": [
        {
          "name": "A√±adir secci√≥n de mazos",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 10-12 horas\n\n## Objetivo\nPantalla para explorar mazos populares e importarlos.\n\n## Funcionalidades\n- Buscar mazos meta (m√°s usados)\n- Ver cartas del mazo\n- Indicar cartas faltantes (sombreado)\n- Importar a tu colecci√≥n\n\n## Implementaci√≥n\nIntegraci√≥n con API de Limitless TCG o base de datos propia de mazos p√∫blicos.\n\n## ‚úÖ Checklist\n- [ ] Dise√±ar UI de exploraci√≥n de mazos\n- [ ] Integrar API de mazos meta (Limitless/OPTD)\n- [ ] Crear componente DeckPreview\n- [ ] Implementar indicador de cartas faltantes\n- [ ] A√±adir bot√≥n importar\n- [ ] Testing de importaci√≥n"
        },
        {
          "name": "Animaci√≥n llamativa al scanear una carta",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 4-6 horas\n\n## Objetivo\nFeedback visual mejorado al escanear cartas.\n\n## Ideas\n- Confetti explosion (react-native-confetti)\n- Part√≠culas doradas (Lottie animation)\n- Shake + glow effect\n- Sonido de √©xito\n\n## Implementaci√≥n\nUsar react-native-reanimated + lottie-react-native.\n\n## ‚úÖ Checklist\n- [ ] Dise√±ar/obtener animaci√≥n Lottie\n- [ ] Integrar react-native-lottie\n- [ ] A√±adir sonido de √©xito\n- [ ] Implementar shake animation\n- [ ] Testing en dispositivos\n- [ ] Configuraci√≥n on/off en settings"
        }
      ]
    },
    {
      "name": "Mejoras",
      "cards": [
        {
          "name": "A√±adir publicidad",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 6-8 horas\n\n## Objetivo\nMonetizaci√≥n mediante anuncios (usuarios free).\n\n## Plataforma\nGoogle AdMob (React Native)\n\n## Tipos de Anuncios\n- Banner (bottom de pantalla)\n- Interstitial (entre escaneos cada X cartas)\n- Rewarded (ver anuncio ‚Üí desbloquear feature)\n\n## Implementaci√≥n\n```bash\nnpm install react-native-google-mobile-ads\n```\n\n## ‚úÖ Checklist\n- [ ] Crear cuenta Google AdMob\n- [ ] Instalar react-native-google-mobile-ads\n- [ ] Configurar Ad Units (iOS/Android)\n- [ ] Implementar Banner en CollectionScreen\n- [ ] Implementar Interstitial cada 10 escaneos\n- [ ] Testing con test IDs\n- [ ] Publicar y obtener real Ad Units"
        },
        {
          "name": "Plantear sistema de compras",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 12-16 horas\n\n## Objetivo\nIn-App Purchases para tier PRO.\n\n## Features PRO\n- Sin publicidad\n- Exportaci√≥n ilimitada\n- Estad√≠sticas avanzadas\n- Backup en la nube\n- Soporte prioritario\n\n## Precio\n- Mensual: ‚Ç¨2.99\n- Anual: ‚Ç¨24.99 (30% descuento)\n\n## Implementaci√≥n\nreact-native-iap + Supabase para validaci√≥n.\n\n## ‚úÖ Checklist\n- [ ] Configurar productos en App Store Connect\n- [ ] Configurar productos en Google Play Console\n- [ ] Instalar react-native-iap\n- [ ] Implementar purchase flow\n- [ ] Validar receipts en Supabase\n- [ ] Actualizar subscription_tier en BD\n- [ ] Implementar restore purchases\n- [ ] Testing con sandbox"
        },
        {
          "name": "Comunidad",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 20-30 horas\n\n## Objetivo\nSecci√≥n social: publicar pulls, comentar, likes.\n\n## Features\n- Feed de actividad (pulls recientes)\n- Comentarios y likes\n- Compartir en redes sociales\n- Achievements/badges\n\n## Complejidad\nAlta - requiere sistema de posts, comentarios, notificaciones.\n\n## ‚úÖ Checklist\n- [ ] Dise√±ar modelo de datos (posts, comments, likes)\n- [ ] Crear FeedScreen\n- [ ] Implementar sistema de posts\n- [ ] A√±adir comentarios\n- [ ] Sistema de notificaciones push\n- [ ] Implementar badges/achievements\n- [ ] Moderaci√≥n de contenido"
        },
        {
          "name": "Encuentra tu tienda",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 8-10 horas\n\n## Objetivo\nMapa con tiendas de TCG cercanas.\n\n## Features\n- Geolocalizaci√≥n\n- Mapa con marcadores\n- Informaci√≥n de tienda (horario, tel√©fono)\n- Navegaci√≥n (Google Maps/Apple Maps)\n\n## Implementaci√≥n\nreact-native-maps + base de datos de tiendas (Google Places API).\n\n## ‚úÖ Checklist\n- [ ] Instalar react-native-maps\n- [ ] Obtener API key de Google Maps\n- [ ] Implementar geolocalizaci√≥n\n- [ ] Integrar Google Places API\n- [ ] Crear StoreMapScreen\n- [ ] A√±adir detalles de tienda\n- [ ] Testing de navegaci√≥n"
        },
        {
          "name": "Torneos",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 30-40 horas\n\n## Objetivo\nSistema completo de gesti√≥n de torneos.\n\n## Features\n- Crear torneo (TO)\n- Inscribirse\n- Brackets/pairings\n- Registro de resultados\n- Rankings\n\n## Complejidad\nMuy alta - requiere sistema de emparejamiento, validaciones complejas.\n\n## ‚úÖ Checklist\n- [ ] Dise√±ar modelo de datos complejo\n- [ ] Crear TournamentsScreen\n- [ ] Implementar sistema de brackets\n- [ ] Sistema de pairings (Swiss/Single Elimination)\n- [ ] Registro de resultados\n- [ ] Rankings y estad√≠sticas\n- [ ] Testing extensivo"
        },
        {
          "name": "Implementar scanner para otros tcgs",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 40-60 horas\n\n## Objetivo\nSoportar m√∫ltiples TCGs (Magic, Pok√©mon, Yu-Gi-Oh!).\n\n## Desaf√≠os\n- Cada TCG tiene formato de c√≥digo diferente\n- M√∫ltiples cat√°logos de cartas\n- APIs diferentes para precios\n- UI multi-juego\n\n## Implementaci√≥n\nSistema de \"juegos\" con parser configurable por juego.\n\n## ‚úÖ Checklist\n- [ ] Dise√±ar arquitectura multi-TCG\n- [ ] Crear tabla 'games'\n- [ ] Parsers espec√≠ficos por juego\n- [ ] Importar cat√°logos (MTG, Pok√©mon, YGO)\n- [ ] Adaptar UI para multi-juego\n- [ ] Testing con cada TCG\n- [ ] Documentar cada juego"
        }
      ]
    },
    {
      "name": "Colecci√≥n",
      "cards": [
        {
          "name": "A√±adir Dones (manualmente)",
          "desc": "**Prioridad:** üü¢ Baja\n**Estimaci√≥n:** 2-3 horas\n\n## Objetivo\nPermitir gestionar cartas DON!! del juego.\n\n## Contexto\nEn One Piece TCG, cada jugador tiene 10 cartas DON!! que no van en el deck.\n\n## Implementaci√≥n\nA√±adir secci√≥n especial \"DON Cards\" con contador (0-10).\n\n## ‚úÖ Checklist\n- [ ] A√±adir campo don_count a profiles\n- [ ] Crear componente DonCounter\n- [ ] A√±adir en ProfileScreen o CollectionScreen\n- [ ] Persistir en BD\n- [ ] Testing"
        }
      ]
    },
    {
      "name": "No queremos pero no hay mas remedio",
      "cards": [
        {
          "name": "Documentaci√≥n",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 8-12 horas\n\n## Objetivo\nDocumentaci√≥n completa del proyecto para desarrolladores.\n\n## Contenido\n- README.md completo\n- Gu√≠a de instalaci√≥n\n- Arquitectura del sistema\n- API documentation\n- Contributing guidelines\n- Changelog\n\n## Herramientas\n- Docusaurus (site documentation)\n- JSDoc para c√≥digo\n- Swagger/OpenAPI para API\n\n## ‚úÖ Checklist\n- [ ] Crear README.md detallado\n- [ ] Documentar instalaci√≥n paso a paso\n- [ ] Diagrams de arquitectura (draw.io)\n- [ ] Documentar API endpoints\n- [ ] Crear CONTRIBUTING.md\n- [ ] Setup Docusaurus (opcional)\n- [ ] Mantener CHANGELOG.md"
        },
        {
          "name": "Pruebas",
          "desc": "**Prioridad:** üü° Media\n**Estimaci√≥n:** 20-30 horas\n\n## Objetivo\nSuite completa de tests automatizados.\n\n## Tipos de Tests\n1. **Unit Tests** (Jest)\n2. **Integration Tests** (Testing Library)\n3. **E2E Tests** (Detox)\n\n## Coverage Objetivo\nM√≠nimo 70% de cobertura en l√≥gica de negocio.\n\n## Implementaci√≥n\n```bash\nnpm install --save-dev @testing-library/react-native jest\n```\n\n## ‚úÖ Checklist\n- [ ] Setup Jest + Testing Library\n- [ ] Tests para utils (cardCodeParser)\n- [ ] Tests para services (supabaseService)\n- [ ] Tests para hooks (useCardScanner)\n- [ ] Tests de componentes cr√≠ticos\n- [ ] Setup Detox para E2E\n- [ ] CI/CD con tests autom√°ticos\n- [ ] Coverage reports"
        },
        {
          "name": "Correo a mkm a ver si nos dejan usar la api",
          "desc": "**Prioridad:** üî¥ Alta\n**Estimaci√≥n:** 1 hora\n\n## Objetivo\nSolicitar acceso oficial a API de Cardmarket.\n\n## Email Template\n```\nSubject: API Access Request - OPSCANNER TCG App\n\nDear Cardmarket Team,\n\nI am the developer of OPSCANNER, a mobile application for One Piece TCG \ncollectors. Our app helps users manage their card collections and would \ngreatly benefit from access to your official API for real-time pricing data.\n\nApp details:\n- Platform: iOS/Android (React Native)\n- Users: [X] active users\n- Purpose: Collection management + price tracking\n- Frequency: ~500 requests/day\n\nWe are committed to:\n- Following your API rate limits\n- Proper attribution to Cardmarket\n- Not competing with your marketplace\n\nCould we discuss API access terms?\n\nBest regards,\n[Your name]\n```\n\n## Follow-up\nSi no responden en 2 semanas, usar soluciones alternativas (scrapping).\n\n## ‚úÖ Checklist\n- [ ] Preparar email profesional\n- [ ] Incluir screenshots de la app\n- [ ] Mencionar n√∫mero de usuarios\n- [ ] Enviar a partnerships@cardmarket.com\n- [ ] Follow-up despu√©s de 1 semana\n- [ ] Si rechazan: implementar scrapper robusto"
        }
      ]
    }
  ]
}